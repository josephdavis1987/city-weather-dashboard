---
title: "City Weather Analysis"
format: html
jupyter: python3
execute:
  echo: true
  warning: false
---

# Setup
```{python}

# ğŸ› ï¸ Setup
import datetime
import calendar
import requests
import numpy as np
import pandas as pd
import plotly.graph_objects as go
from statsmodels.nonparametric.smoothers_lowess import lowess

```

# LEOSS-cyclic code to 'wrap' the data
### This is used later to help correct the LOESS error around edges

```{python}

def loess_cyclic(x, y, frac=0.1):
    """
    LOESS smoothing on a cyclic domain.
    - x: 1D array of day-of-year (1â€¦n)
    - y: measurements (same length)
    - frac: LOESS span (fraction of points)
    Returns y_smoothed of length n.
    """
    x = np.asarray(x)
    y = np.asarray(y)
    n = len(x)
    # number of neighbors â‰ˆ frac * n
    k = max(int(frac * n), 1)

    # build extended arrays: last k days mapped to -(n-kâ€¦n), then original, then first k days mapped to (n+1â€¦n+k)
    x_ext = np.concatenate((x[-k:] - n, x, x[:k] + n))
    y_ext = np.concatenate((y[-k:], y, y[:k]))

    # run LOESS on the extended series
    sm_ext = lowess(y_ext, x_ext, frac=frac)
    # sm_ext is sorted by x_ext, so sm_ext[:,1] aligns with x_ext

    # extract just the middle block back
    y_sm = sm_ext[k:k+n, 1]
    return y_sm

```

# Filter for City
```{python}

# 1) Define a Python variable for the city:
city = "Birmingham"

# choose a smoothing span: frac=0.1 means ~10% of the points in each local fit
my_frac = 0.025

# â”€â”€ LOAD PRECOMPUTED HISTORIC AGGREGATES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# This CSV was generated by precompute_all_cities.py and contains one row per (city, day_of_year).
# It already has columns: avg_t, avg_tmin, avg_tmax, min_t, max_t,
#                         avg_precip, min_precip, max_precip,
#                         avg_cum_precip, std_cum_precip, min_cum_precip, max_cum_precip
precompute_path = "../data/precompute_weather.csv"
all_agg = pd.read_csv(precompute_path)

# Filter out only the rows for our chosen city, then sort by day_of_year:
agg = all_agg[all_agg["city"] == city].sort_values("day_of_year").copy()

# â”€â”€ 3) CONVERT ALL TEMPERATURE COLUMNS TO Â°F â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Precomputed CSV has these columns (in Â°C):
#    ['avg_tmin', 'avg_tmax', 'min_t', 'max_t']
# We need them in Â°F:
for col in ["avg_tmin", "avg_tmax", "min_t", "max_t"]:
    agg[col] = agg[col] * 9/5 + 32

# (If you also used 'avg_t' itself, convert that too:)
if "avg_t" in agg.columns:
    agg["avg_t"] = agg["avg_t"] * 9/5 + 32

# LOESS fits return an array of (x, smoothed_y)
agg['tmin_loess']  = loess_cyclic(agg['day_of_year'], agg['avg_tmin'],  frac=my_frac)
agg['tmax_loess'] = loess_cyclic(agg['day_of_year'], agg['avg_tmax'], frac=my_frac)

agg['precip_loess'] = loess_cyclic(agg['day_of_year'], agg['avg_precip'], frac=my_frac)
agg['cum_precip_loess'] = loess_cyclic(agg['day_of_year'], agg['avg_cum_precip'], frac=my_frac)


#agg.head()
#agg.tail()
```

#  Call API for most recent year
```{python}

'''
- **A)** loads your city list and grabs the lat/lon for whatever `city` you defined.  
- **B)** sets the NASA POWER date range from January 1, 2025 to today.  
- **C)** requests a JSON for T2M_MAX/T2M_MIN/PRECTOTCORR.  
- **D)** builds a tiny `df2025` with date, tmax, tmin, precip, then converts temp to Fahrenheit.  
- **E)** groups into a 2025â€only â€œrecordâ€ DataFrame `agg2025` with columns `day_of_year`, `min_t2025`, `max_t2025`.
'''

# â”€â”€ A) Find lat/lon for your city â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cities_path = "../data/Southeast_US_Cities.csv"
cities_df   = pd.read_csv(cities_path)
row         = cities_df.loc[cities_df["city"] == city].iloc[0]
lat, lon    = float(row["lat"]), float(row["lon"])

# â”€â”€ B) Compute start/end for the 2025 fetch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
start_2025 = "20250101"
today      = datetime.date.today()  # e.g. 2025-06-01
end_2025   = today.strftime("%Y%m%d")  # "20250601", for example

# â”€â”€ C) Hit NASA POWER for T2M_MAX, T2M_MIN, PRECTOTCORR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
url_2025 = (
    "https://power.larc.nasa.gov/api/temporal/daily/point"
    f"?parameters=T2M_MAX,T2M_MIN,PRECTOTCORR"
    f"&community=AG"
    f"&longitude={lon}&latitude={lat}"
    f"&start={start_2025}&end={end_2025}"
    f"&format=JSON"
)
r2025 = requests.get(url_2025)
data2025 = r2025.json()["properties"]["parameter"]

# â”€â”€ D) Build a DataFrame for 2025 values, then convert to Â°F â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
dates_2025 = list(data2025["T2M_MAX"].keys())
df2025 = pd.DataFrame({
    "date"  : pd.to_datetime(dates_2025, format="%Y%m%d"),
    "tmax"  : list(data2025["T2M_MAX"].values()),
    "tmin"  : list(data2025["T2M_MIN"].values()),
    "precip": list(data2025["PRECTOTCORR"].values()),
})
# Convert to Â°F
df2025[["tmax","tmin"]] = df2025[["tmax","tmin"]] * 9/5 + 32

# Create day_of_year
df2025["day_of_year"] = df2025["date"].dt.dayofyear

# Now compute a simple cumulative sum in calendar order:
df2025["cum_precip"] = df2025["precip"].cumsum()

# 1) Replace POWERâ€™s missingâ€data sentinels with NaN.
#    NASA POWER uses âˆ’999 and -1766 for missing T2M_MAX/T2M_MIN/precip (and sometimes âˆ’99 or other codes).
df2025 = df2025.replace({
    "tmax": {-1766.2: np.nan},
    "tmin": {-1766.2: np.nan},
    "precip": {-999: np.nan}
})

# 2) (Optional) Drop any rows that are now fully missingâ€”or just where both tmax & tmin are NaN.
df2025 = df2025.dropna(subset=["tmax", "tmin", "precip"], how="all")


```

# Build the figure
```{python}

# â”€â”€ Compute monthâ€start ticks in "day_of_year" coordinates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Use any nonâ€leap year (e.g. 2021) to map monthâ†’day_of_year:
month_vals  = []
month_names = []
for m in range(1, 13):
    dt = datetime.date(2021, m, 1)                  # choose 2021 (nonâ€leap) 
    doy = dt.timetuple().tm_yday                    # day_of_year (1â€“365)
    month_vals.append(doy)
    month_names.append(calendar.month_abbr[m])      # e.g. "Jan", "Feb", â€¦

# ribbon + smoothed lines 
fig = go.Figure()

# ribbon (minâ†’max range)
fig.add_trace(go.Scatter(
    x=agg.day_of_year, y=agg.min_t,
    mode='lines', line_color='rgba(0,0,0,0)', showlegend=False
))
fig.add_trace(go.Scatter(
    x=agg.day_of_year, y=agg.max_t,
    mode='lines', fill='tonexty',
    fillcolor='rgba(72, 194, 216, 0.3)',
    line_color='rgba(0,0,0,0)',
    name='Daily Record Values'
))

# 1) Invisible â€œbottomâ€ trace for LOESS low
fig.add_trace(go.Scatter(
    x=agg.day_of_year,
    y=agg.tmin_loess,
    mode='lines',
    line=dict(color='rgba(0,0,0,0)'),  # fully transparent
    showlegend=False
))

# 2) Filled â€œribbonâ€ top trace for LOESS high
fig.add_trace(go.Scatter(
    x=agg.day_of_year,
    y=agg.tmax_loess,
    mode='lines',
    fill='tonexty',                        # fill down to the previous trace
    fillcolor='rgba(25, 50, 195, 0.2)',      # translucent blue
    line=dict(color='rgba(25, 116, 195, 0)'),
    name=f'Historic Average Range (LOESS frac={my_frac})'
))

# 2) Build a red ribbon between tminâ†’tmax for 2025
fig.add_trace(go.Scatter(
    x=df2025.day_of_year,
    y=df2025.tmin,
    mode='lines',
    line=dict(color='rgba(0,0,0,0)'),
    showlegend=False
))
fig.add_trace(go.Scatter(
    x=df2025.day_of_year,
    y=df2025.tmax,
    mode='lines',
    fill='tonexty',
    fillcolor='rgba(255, 0, 0, 0.36)',    # translucent red
    line_color='rgba(0,0,0,0)',
    name='Live 2025 Range'
))

fig.update_layout(
    title= f"{city}: Avg Temp by Day of Year with record values, 1990 - 2024, Live data starting 2025",
    xaxis=dict(
        title="Day of Year",
        tickmode="array",
        tickvals=month_vals,
        ticktext=month_names,
        tickangle=-45
    ),
    yaxis_title="Temperature (Â°F)",
    height=650,
    legend=dict(
        x=0.005,            # 0 = left of plot, 1 = right of plot
        y=0.98,            # 0 = bottom of plot, 1 = top of plot
        xanchor="left",   # which side of the legend box is at x
        yanchor="top",     # which side of the legend box is at y
        bgcolor="rgba(255,255,255,0.7)",  # semi-transparent white
        bordercolor="black",
        borderwidth=1
    )
)
fig.show()

```

# â”€â”€ Cumulative Precipitation Plot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```{python}

fig = go.Figure()

# (1) Historic full range ribbon: min_cum_precip â†’ max_cum_precip (light blue)
fig.add_trace(go.Scatter(
    x=agg.day_of_year,
    y=agg.min_cum_precip,
    mode='lines',
    line=dict(color='rgba(0,0,0,0)'),
    showlegend=False
))
fig.add_trace(go.Scatter(
    x=agg.day_of_year,
    y=agg.max_cum_precip,
    mode='lines',
    fill='tonexty',
    fillcolor='rgba(72,194,216,0.2)',   # pale translucent blue
    line=dict(color='rgba(0,0,0,0)'),
    name='Historic Record Range (minâ†’max)'
))

# (2) Â±1 STD ribbon around avg: (avg - std) â†’ (avg + std)
#    First draw the lower edge (avg - std), invisible
fig.add_trace(go.Scatter(
    x=agg.day_of_year,
    y=agg.avg_cum_precip - agg.std_cum_precip,
    mode='lines',
    line=dict(color='rgba(0,0,0,0)'),
    showlegend=False
))
#    Then draw the upper edge (avg + std) and fill down to the lower edge
fig.add_trace(go.Scatter(
    x=agg.day_of_year,
    y=agg.avg_cum_precip + agg.std_cum_precip,
    mode='lines',
    fill='tonexty',
    fillcolor='rgba(38,124,186,0.3)',    # slightly darker translucent blue
    line=dict(color='rgba(38,124,186,0)'), 
    name='Historic Â±1 Std Dev'
))

# (3) Historic average: a solid blue line at avg_cum_precip
fig.add_trace(go.Scatter(
    x=agg.day_of_year,
    y=agg.avg_cum_precip,
    mode='lines',
    line=dict(color='rgb(38,124,186)', width=3),
    name='Historic Average'
))

# (4) Live 2025 cumulative line (solid red)
fig.add_trace(go.Scatter(
    x=df2025.day_of_year,
    y=df2025.cum_precip,
    mode='lines',
    line=dict(color='rgb(195,25,25)', width=3),
    name='Live 2025 Cumulative'
))

# Layout (autoâ€scale y)
fig.update_layout(
    title=f"{city}: Cumulative Precipitation by Day of Year",
    xaxis=dict(
        title="Day of Year",
        tickmode="array",
        tickvals=month_vals,
        ticktext=month_names,
        tickangle=-45,
        showgrid=False
    ),
    yaxis=dict(
        title="Cumulative Precipitation (mm)",
        gridcolor='rgba(200,200,200,0.2)'
    ),
    height=650,
    legend=dict(
        x=0.005, y=0.98,
        xanchor="left", yanchor="top",
        bgcolor="rgba(255,255,255,0.7)",
        bordercolor="black", borderwidth=1
    )
)

fig.show()

```

# â”€â”€ Daily Precipitation: Historic Max as Ribbon + 2025 Bars â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```{python}

fig = go.Figure()

# (1) Historic ribbon: 0 â†’ max_precip (light blue fill)
fig.add_trace(go.Scatter(
    x=agg.day_of_year,
    y=agg.max_precip,
    mode='lines',
    line=dict(color='rgba(72,194,216,0)'),   # make the top edge invisible
    fill='tozeroy',
    fillcolor='rgba(72,194,216,0.3)',         # translucent blue
    name='Historic Max Precip'
))

# (2) Live 2025 ribbon: 0 â†’ precip (translucent red)
fig.add_trace(go.Scatter(
    x=df2025.day_of_year,
    y=df2025.precip,
    mode='lines',
    line=dict(color='rgba(195,25,25,0)'),     # no visible top edge
    fill='tozeroy',
    fillcolor='rgba(195, 25, 25, 0.64)',          # translucent red
    name='Live 2025 Precip'
))

# (3) LOESS-smoothed historic average precip (dashed blue line)
fig.add_trace(go.Scatter(
    x=agg.day_of_year,
    y=agg.precip_loess,
    mode='lines',
    line=dict(color='rgb(38,124,186)', width=3, dash='dash'),
    name='Historical Avg Precip (LOESS)'
))

# â”€â”€ Layout tweaks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
max_all = max(agg.max_precip.max(), df2025.precip.max()) * 1.05

fig.update_layout(
    title=f"{city}: Historic Max as Ribbon vs Live 2025 Bars",
    xaxis=dict(
        title="Day of Year",
        tickmode="array",
        tickvals=month_vals,
        ticktext=month_names,
        tickangle=-45,
        showgrid=False
    ),
    yaxis=dict(
        title="Precipitation (mm/day)",
        range=[0, max_all],
        gridcolor='rgba(200,200,200,0.2)'
    ),
    barmode='overlay',
    bargap=0,
    bargroupgap=0,
    height=650,
    legend=dict(
        x=0.005, y=0.98,
        xanchor="left", yanchor="top",
        bgcolor="rgba(255,255,255,0.7)",
        bordercolor="black", borderwidth=1
    )
)

fig.show()
```

